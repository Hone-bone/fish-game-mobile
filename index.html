<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <title>é‡‘é­šã™ãã„ã‚²ãƒ¼ãƒ </title>
    <link rel="stylesheet" href="css/style.css" />
    <!-- PWAé–¢é€£ -->
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#5ea6df" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <link rel="apple-touch-icon" href="assets/app-icon.png" />
    <!-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
    />
    <!-- ã‚µã‚¦ãƒ³ãƒ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <!-- Hammer.js ã‚¿ãƒƒãƒæ“ä½œç”¨ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>

    <script>
      // æœ€åˆã«èª­ã¿è¾¼ã‚€ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
      window.onload = function () {
        console.log("Window onload");
        const startButton = document.getElementById("start-button");
        if (startButton) {
          startButton.onclick = function () {
            console.log("ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯");
          };
        }
      };
    </script>
  </head>
  <body>
    <!-- ç«¯æœ«ã®å‘ãé€šçŸ¥ -->
    <div id="orientation-message">
      <p>ã“ã®ã‚²ãƒ¼ãƒ ã¯ç¸¦å‘ãã§éŠã¶ã®ãŒãŠã™ã™ã‚ã§ã™</p>
      <div class="rotate-icon">ğŸ“±</div>
      <p>ç«¯æœ«ã‚’ç¸¦å‘ãã«ã—ã¦ãã ã•ã„</p>
    </div>

    <div class="game-container">
      <div class="game-header">
        <div class="score-container">ã‚¹ã‚³ã‚¢: <span id="score">0</span></div>
        <div class="timer-container">
          æ®‹ã‚Šæ™‚é–“: <span id="timer">60</span>ç§’
        </div>
      </div>

      <div class="game-area">
        <canvas id="game-canvas"></canvas>
        <div id="poi-container">
          <img id="poi" src="assets/poi.svg" alt="ãƒã‚¤" />
        </div>
        <div id="splash-container"></div>
      </div>

      <div class="game-controls">
        <button id="start-button">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        <div class="instructions">
          <h3>éŠã³æ–¹</h3>
          <p>
            ãƒã‚¤ã‚’ä½¿ã£ã¦é‡‘é­šã‚’ã™ãã£ã¦ãã ã•ã„ï¼åˆ¶é™æ™‚é–“å†…ã«ã§ãã‚‹ã ã‘å¤šãã®é‡‘é­šã‚’ã™ãã„ã¾ã—ã‚‡ã†ã€‚
          </p>
          <p>
            é‡‘é­šã®ç¨®é¡ã«ã‚ˆã£ã¦ã‚¹ã‚³ã‚¢ãŒç•°ãªã‚Šã¾ã™ã€‚ãƒ¬ã‚¢ãªé‡‘é­šã‚’ç‹™ã„ã¾ã—ã‚‡ã†ï¼
          </p>
        </div>
      </div>

      <div id="game-over" class="hidden">
        <div class="game-over-content animate__animated animate__zoomIn">
          <h2>ã‚²ãƒ¼ãƒ çµ‚äº†!</h2>
          <p>æœ€çµ‚ã‚¹ã‚³ã‚¢: <span id="final-score">0</span></p>
          <button id="restart-button">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
          <button id="share-button">çµæœã‚’ã‚·ã‚§ã‚¢</button>
        </div>
      </div>
    </div>

    <script>
      // ã‚·ãƒ³ãƒ—ãƒ«ã§åŸºæœ¬çš„ãªã‚²ãƒ¼ãƒ æ©Ÿèƒ½ã‚’å®Ÿè£…
      document.addEventListener("DOMContentLoaded", function () {
        // ã‚²ãƒ¼ãƒ è¦ç´ 
        const canvas = document.getElementById("game-canvas");
        const ctx = canvas.getContext("2d");
        const startButton = document.getElementById("start-button");
        const restartButton = document.getElementById("restart-button");
        const shareButton = document.getElementById("share-button");
        const timerElement = document.getElementById("timer");
        const scoreElement = document.getElementById("score");
        const gameOverScreen = document.getElementById("game-over");
        const finalScoreElement = document.getElementById("final-score");
        const poiContainer = document.getElementById("poi-container");
        const poiElement = document.getElementById("poi");
        const splashContainer = document.getElementById("splash-container");

        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        let gameState = {
          isPlaying: false,
          score: 0,
          timeRemaining: 60,
          timeInterval: null,
          fish: [],
          lastTouchX: 0,
          lastTouchY: 0,
          poiCatchAttempts: 0,
          poiBroken: false,
        };

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã®è¨­å®š
        function resizeCanvas() {
          const gameArea = document.querySelector(".game-area");
          canvas.width = gameArea.offsetWidth;
          canvas.height = gameArea.offsetHeight;

          // ã‚²ãƒ¼ãƒ å†…å®¹ã®å†æç”»
          if (gameState.isPlaying) {
            drawWaterPattern();
            drawFish();
          }
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹é–¢æ•°
        function startGame() {
          console.log("ã‚²ãƒ¼ãƒ é–‹å§‹");
          if (gameState.isPlaying) return;

          // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®ãƒªã‚»ãƒƒãƒˆ
          gameState.isPlaying = true;
          gameState.score = 0;
          gameState.timeRemaining = 60;
          gameState.poiCatchAttempts = 0;
          gameState.poiBroken = false;
          gameState.fish = [];

          // è¡¨ç¤ºã®æ›´æ–°
          scoreElement.textContent = "0";
          timerElement.textContent = "60";

          // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã‚’éè¡¨ç¤º
          gameOverScreen.classList.add("hidden");

          // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
          startButton.style.display = "none";
          document.querySelector(".instructions").style.display = "none";

          // åˆæœŸé­šã‚’ç”Ÿæˆ
          for (let i = 0; i < 5; i++) {
            createFish();
          }

          // ã‚¿ã‚¤ãƒãƒ¼ã®é–‹å§‹
          gameState.timeInterval = setInterval(updateTimer, 1000);

          // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹
          requestAnimationFrame(gameLoop);
        }

        // ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
        function updateTimer() {
          gameState.timeRemaining--;
          timerElement.textContent = gameState.timeRemaining;

          if (gameState.timeRemaining <= 0) {
            endGame();
          }
        }

        // ã‚²ãƒ¼ãƒ çµ‚äº†
        function endGame() {
          gameState.isPlaying = false;
          clearInterval(gameState.timeInterval);

          // æœ€çµ‚ã‚¹ã‚³ã‚¢ã®è¡¨ç¤º
          finalScoreElement.textContent = gameState.score;

          // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã®è¡¨ç¤º
          gameOverScreen.classList.remove("hidden");

          // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’å†è¡¨ç¤º
          startButton.style.display = "block";
          document.querySelector(".instructions").style.display = "block";
        }

        // é­šã®ç”Ÿæˆ
        function createFish() {
          const fishColors = ["red", "gold", "blue", "black"];
          const fishSizes = [30, 25, 20, 35];
          const fishPoints = [10, 20, 30, 50];

          const randomIndex = Math.floor(Math.random() * fishColors.length);

          // é­šã®é–‹å§‹ä½ç½®
          const startFromSide = Math.random() > 0.5;
          let x, y, directionX, directionY;

          if (startFromSide) {
            x = Math.random() > 0.5 ? 0 : canvas.width;
            y = Math.random() * canvas.height;
            directionX = x === 0 ? 1 : -1;
            directionY = Math.random() * 2 - 1;
          } else {
            x = Math.random() * canvas.width;
            y = Math.random() > 0.5 ? 0 : canvas.height;
            directionX = Math.random() * 2 - 1;
            directionY = y === 0 ? 1 : -1;
          }

          // é­šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
          const fish = {
            x: x,
            y: y,
            size: fishSizes[randomIndex],
            color: fishColors[randomIndex],
            points: fishPoints[randomIndex],
            directionX: directionX,
            directionY: directionY,
            rotation: Math.atan2(directionY, directionX),
          };

          gameState.fish.push(fish);
        }

        // é­šã®æ›´æ–°
        function updateFish() {
          gameState.fish.forEach((fish) => {
            // é­šã®ç§»å‹•
            fish.x += fish.directionX * 2;
            fish.y += fish.directionY * 2;

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ç«¯ã«åˆ°é”ã—ãŸã‚‰å‘ãã‚’å¤‰ãˆã‚‹
            if (fish.x <= 0 || fish.x >= canvas.width) {
              fish.directionX *= -1;
            }
            if (fish.y <= 0 || fish.y >= canvas.height) {
              fish.directionY *= -1;
            }

            // å›è»¢è§’åº¦ã®æ›´æ–°
            fish.rotation = Math.atan2(fish.directionY, fish.directionX);
          });

          // ä¸€å®šã®ç¢ºç‡ã§æ–°ã—ã„é­šã‚’è¿½åŠ 
          if (Math.random() < 0.02 && gameState.fish.length < 15) {
            createFish();
          }
        }

        // é­šã®æç”»
        function drawFish() {
          gameState.fish.forEach((fish) => {
            ctx.save();
            ctx.translate(fish.x, fish.y);
            ctx.rotate(fish.rotation);

            // é­šã®ä½“
            ctx.fillStyle = fish.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, fish.size / 2, fish.size / 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // å°¾ã³ã‚Œ
            ctx.beginPath();
            ctx.moveTo(fish.size / 2, 0);
            ctx.lineTo(fish.size, fish.size / 4);
            ctx.lineTo(fish.size, -fish.size / 4);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
          });
        }

        // æ°´ã®èƒŒæ™¯æç”»
        function drawWaterPattern() {
          // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // é’ã„èƒŒæ™¯
          ctx.fillStyle = "#5ea6df";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // æ°´ã®æ³¢ç´‹
          ctx.save();
          ctx.globalAlpha = 0.1;
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.arc(
              canvas.width / 2,
              canvas.height / 2,
              50 + i * 40,
              0,
              Math.PI * 2
            );
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 5;
            ctx.stroke();
          }
          ctx.restore();
        }

        // ãƒã‚¤ã®ä½ç½®ã‚’æ›´æ–°
        function updatePoiPosition(x, y) {
          poiContainer.style.left = `${x - 40}px`;
          poiContainer.style.top = `${y - 40}px`;
          gameState.lastTouchX = x;
          gameState.lastTouchY = y;
        }

        // æ°´ã—ã¶ãã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        function createSplash(x, y) {
          const splash = document.createElement("div");
          splash.className = "splash";
          splash.style.left = `${x}px`;
          splash.style.top = `${y}px`;

          splashContainer.appendChild(splash);

          setTimeout(() => {
            splash.remove();
          }, 600);
        }

        // é­šã‚’ã™ãã†
        function catchFish(x, y) {
          if (gameState.poiBroken) return;

          // ãƒã‚¤ã®ä½¿ç”¨å›æ•°ã‚’å¢—ã‚„ã™
          gameState.poiCatchAttempts++;

          // ãƒã‚¤ãŒå£Šã‚ŒãŸã‹ãƒã‚§ãƒƒã‚¯
          if (gameState.poiCatchAttempts >= 5) {
            gameState.poiBroken = true;
            setTimeout(() => {
              gameState.poiBroken = false;
              gameState.poiCatchAttempts = 0;
            }, 3000);
            return;
          }

          // é­šã‚’æ•ã¾ãˆãŸã‹ãƒã‚§ãƒƒã‚¯
          gameState.fish.forEach((fish, index) => {
            const distance = Math.sqrt(
              Math.pow(fish.x - x, 2) + Math.pow(fish.y - y, 2)
            );

            if (distance < 40) {
              // ã‚¹ã‚³ã‚¢åŠ ç®—
              gameState.score += fish.points;
              scoreElement.textContent = gameState.score;

              // é­šã‚’å‰Šé™¤
              gameState.fish.splice(index, 1);

              // æ–°ã—ã„é­šã‚’è¿½åŠ 
              createFish();
            }
          });
        }

        // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        function gameLoop() {
          if (!gameState.isPlaying) return;

          // èƒŒæ™¯ã¨é­šã®æç”»
          drawWaterPattern();
          updateFish();
          drawFish();

          // æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ 
          requestAnimationFrame(gameLoop);
        }

        // ãƒã‚¦ã‚¹ã¨ã‚¿ãƒƒãƒã®ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener("mousedown", (e) => {
          if (!gameState.isPlaying) return;
          const rect = canvas.getBoundingClientRect();
          updatePoiPosition(e.clientX - rect.left, e.clientY - rect.top);
          poiContainer.style.display = "block";
        });

        canvas.addEventListener("mousemove", (e) => {
          if (!e.buttons || !gameState.isPlaying) return;
          const rect = canvas.getBoundingClientRect();
          updatePoiPosition(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener("mouseup", (e) => {
          if (!gameState.isPlaying) return;
          const rect = canvas.getBoundingClientRect();
          catchFish(e.clientX - rect.left, e.clientY - rect.top);
          poiContainer.style.display = "none";
          createSplash(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener("touchstart", (e) => {
          if (!gameState.isPlaying) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const touch = e.touches[0];
          updatePoiPosition(
            touch.clientX - rect.left,
            touch.clientY - rect.top
          );
          poiContainer.style.display = "block";
        });

        canvas.addEventListener("touchmove", (e) => {
          if (!gameState.isPlaying) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const touch = e.touches[0];
          updatePoiPosition(
            touch.clientX - rect.left,
            touch.clientY - rect.top
          );
        });

        canvas.addEventListener("touchend", (e) => {
          if (!gameState.isPlaying) return;
          e.preventDefault();
          catchFish(gameState.lastTouchX, gameState.lastTouchY);
          poiContainer.style.display = "none";
          createSplash(gameState.lastTouchX, gameState.lastTouchY);
        });

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        startButton.addEventListener("click", startGame);
        restartButton.addEventListener("click", startGame);

        // åˆæœŸåŒ–
        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();
        drawWaterPattern();

        console.log("ã‚²ãƒ¼ãƒ åˆæœŸåŒ–å®Œäº†");
      });
    </script>
  </body>
</html>
